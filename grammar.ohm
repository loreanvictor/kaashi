Kaashi {
  Expr = Block
       | Pattern
       | Lambda
       | Pipeline
       | Operation
       | Attr
       | Index
       | Paranthesis
       | Atomic


  Block = open_block (Rule block_sep)* Rule? close_block

  Rule = Named_parametric_rule
       | Parametric_rule
       | Key_rule
       | Constant_rule
       | Expr

  Named_parametric_rule = name Parametric_rule
  Parametric_rule = Args+ def Expr
  Key_rule = name def Expr
  Constant_rule = Value def Expr


  Pattern = open_block (Matching block_sep)* Matching? close_block
  Matching = Expr Condition
  Condition = subject_to (Expr | otherwise)


  Lambda = Args+ override Expr

  Args = open_index (Arg arg_sep)* Arg close_index
  Arg = Destructuring_arg
      | Variable_arg
      | Constant_arg

  Destructuring_arg = Destructuring (subject_to Expr)?
  Destructuring =
    open_block
      (Destructuring_element arg_sep)*
      (Destructuring_element)?
    close_block
  Destructuring_element = Destructuring | destructuring_name | name
  destructuring_name = rest name

  Variable_arg = name Default_value? (subject_to Expr)?
  Default_value = open_paran default Expr close_paran
  Constant_arg = Value


  Pipeline = (Pipeline | Pipeline_operand) pipe Pipeline_operand
  Pipeline_operand = Operation | Operand

  Operation = Operand (Operation | Operand)
  Operand = ~pipe 
          ( Attr
          | Index
          | Atomic
          | Paranthesis
          )
  
  Attr = (Attr | Attr_operand) access Attr_operand
  Attr_operand = Index
               | Atomic
               | Paranthesis
  
  Index = (Index | Index_operand | from) open_index (Expr arg_sep)* Expr close_index
  Index_operand = Atomic | Paranthesis
  
  Paranthesis = open_paran Expr close_paran

  Atomic = variable | Value | env | operator
  name = variable | operator
  
  env = "$" variable
  variable = ~reserved (var_letter (var_letter | alnum)*)
  var_letter = "_" | letter

  Value = boolean | number | String

  String = Template_string
         | single_quote_string
         | dbl_quote_string
  Template_string = "`" (template_valid | Template_expr)* "`"
  template_valid = ~("`" | "{") any
  Template_expr = open_block Expr close_block
  single_quote_string = "'" (~"'" any)* "'"
  dbl_quote_string = "\"" (~"\"" any)* "\""
  
  number = bto | decimal
  bto = ddigit+ decimal?
  decimal = "." ddigit+
  ddigit = digit
         | "_"
  
  boolean = true
          | false
  
  operator = ~pipe
           ( rest
           | is | and | or | not
           | "==" | "!=" | "=>" | "<=" | ">=" | "=<" | "&&" | "||" | "++" | "--" | "**"
           | ">>" | "<<" | "^^" | "??" | "!!"
           | "+" | "-" | "*" | "/" | "=" | "!" | "&" | "%" | "~" | "?" | ">" | "<"
           | "^"
           )
  
  otherwise = "otherwise"
  and = "and"
  or = "or"
  not = "not"
  is = "is"
  true = "true"
  false = "false"
  default = "default"
  reserved = otherwise | and | or | not | is | true | false | default
  
  block_sep = ";" | ","
  arg_sep = ","
  subject_to = "|"
  open_block = "{"
  close_block = "}"
  open_index = "["
  close_index = "]"
  open_paran = "("
  close_paran = ")"
  from = "@from"
  def = extend | override
  override = ":"
  extend = "::"
  access = "."
  rest = "..."
  pipe = "->"
  ss = empty+
  s = empty*
  empty = space | comment
  comment = line_comment | multi_comment | endless_comment
  line_comment = "//" (~"\n" any)*
  multi_comment = "/*" (~"*/" any)* "*/"
  endless_comment = "/*" (~"*/" any)*
}