; Specification for this document:
; https://tools.ietf.org/html/rfc5234
; # Core ABNF rules
ALPHA          =  %x41-5A / %x61-7A   ; A-Z / a-z
CR             =  %x0D ; carriage return
HTAB           =  %x09 ; horizontal tab
LF             =  %x0A ; linefeed
SP             =  " "
WSP            =  SP / HTAB ; white space
CRLF           =  CR LF ; Internet standard newline
LWSP           =  *(WSP / CRLF WSP)
                    ; Use of this linear-white-space rule
                    ;  permits lines containing only white
                    ;  space that are no longer legal in
                    ;  mail headers and have caused
                    ;  interoperability problems in other
                    ;  contexts.
                    ; Do not use when defining mail
                    ;  headers and use with caution in
                    ;  other contexts.

; # Primitive values

primitive = boolean / number / string

; ## Numbers

non-zero = "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9";
zero = "0";
digit = zero / non-zero;
number = non-zero *digit ["." 1*digit];

; ## Strings
;
; For simplicity only ASCII characters are defined here,
; but it is highly recommended for all parser / compilers
; to support a more encompassing encoding such as utf-8

squote = "'" ; single quote
dquote = %x22 ; double quote 
char-not-squote = %x01-26 / %x28-7F; all characters except NULL and single quote
char-not-dquote = %x01-21 / %x23-7F; all characters except NULL and double quote

string = (squote *char-not-squote squote) / (dquote *char-not-dquote dquote);

; ## Boolean

true = %s"true";
false = %s"false";
boolean = true / false;

; # Expressions and Compound Values

single-expr = object / primitive / identifier
expr = single-expr / ( expr "." identifier ) / ( expr "[" LWSP expr LWSP "]" ) / ( expr 1*WSP expr ) / ( "(" LWSP expr LWSP ")" )

; ## Identifiers
; DISCUSSION: we can add more chars. also we have option 
; to loose and just except the special chars (quotes, dot,
; braces, brackets, parantheses and colon) which is not recommmended.

char-identifier-operators = "+" / "-" / "*" / "/" / ">" / "<" / "=" / "!" / "@" / "#" / "$" / "%" / "^" / "&" / "_" 
identifier = (ALPHA / char-identifier-operators) *(ALPHA / char-identifier-operators / digit)

; ## Object
; DISCUSSION: the syntax for unboxed-key is not obvious
; specifically, key-values of unbox-entry aren't obvious
; that which one is dummy and which one is bound.
unbox-entry = ( constant-key LWSP ":" LWSP constant-key ) / constant-key
unboxed-key = "{" LWSP [unbox-entry *(LWSP delimiter LWSP unbox-entry)] LWSP "}"
constant-key = primitive / identifier *( "." identifier )
; DISCUSSION: do we need something like constant after 
; paremeteric key?
; {
;    [x].twice : x * 2
; }
parameteric-key = [constant-key / parameteric-key] "[" LWSP parameteric-args [ "|" expr ] LWSP "]"

key = constant-key / parameteric-key / unboxed-key

parameteric-arg = identifier / ( "..." identifier ) / ( "{" LWSP parameteric-args LWSP "}" ) / ( constant-key LWSP ":" LWSP parameteric-arg )
parameteric-args = parameteric-arg LWSP *(delimiter LWSP parameteric-args)

definition = key LWSP ":" LWSP expr

extension = [key] LWSP "::" LWSP expr 

lambda-object = definition
indexed-definition = expr

delimiter =  ";" / ","
object-entry = (definition  / extension / indexed-definition)
object = "{" LWSP [object-entry *(LWSP delimiter LWSP object-entry)] LWSP "}" / lambda-object
